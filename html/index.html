<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rl-4.00.00: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rl-4.00.00
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">rl-4.00.00 Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>The rl library is not a framework where you can plug your own algorithms by complying to predefined interfaces. It is rather a set of tools that helps you designing your work or experiment from scratch. The main function is yours, and you are responsible for scheduling everything from it, for creating every object that you need.</p>
<p>In such a design, the library offers ready-to-use algorithms and types written as templates. Using the template is equivalent as asking some programmer to write for you a code that is dedicated to your application.</p>
<p>This documentation contains both a reference and a user manual. The reference manual is given by the Doxygen structure of class names, as usually. The user manual is a better way to get familiar with the library. The user manual, here, consists of the set of examples. You can start by reading them, <b>in the suggested order</b> (examples all have a number).</p>
<p>The use of templates may be considered as adding programming complexity. The point is that this kind of genericity, based on a re-writing mechanism at compiling time that writes code for you, makes the design close to the mathematics. The cost is that you spend time to make sure that you fit the requirements when you use some rl object. If you don't, you will get some very complicated syntax error message. This is clearly the drawback of the use of templates. Nevertheless, once it compiles, the code you get is quite safe. Our philosophy is that fixing syntax error is a finite process, as opposed to bug fixing.</p>
<h1><a class="anchor" id="tailor"></a>
Tailoring your code with typedefs</h1>
<p>As you will see when browsing examples, it often contains a list of typedefs. This is a smart way to cope with quite complicated types generated by templates. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="a00233.html">rl::problem::mountain_car::DefaultParam</a>        mcParam;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="a00241.html">rl::problem::mountain_car::Simulator&lt;mcParam&gt;</a>  Simulator;</div><div class="line"><span class="keyword">typedef</span> Simulator::action_type                         A;</div></div><!-- fragment --><p> So when you write afterward: </p><div class="fragment"><div class="line">A optimal_action;</div></div><!-- fragment --><p> It is as if you had written: </p><div class="fragment"><div class="line"><a class="code" href="a00134.html#a03a65a26d21884e4a242f49f6b3394db">rl::problem::mountain_car::Simulator&lt;rl::problem::mountain_car::DefaultParam&gt;::action_type</a> optimal_action;</div></div><!-- fragment --><p> This raises a problem when syntax error occur, since error message displays the complicated version of your types.</p>
<h1><a class="anchor" id="concept"></a>
The use of concepts</h1>
<p>There is not a clean support of concepts in the version of c++ that we use. In order to help the designers, we have made explicit concepts in classes, that are just aimed at being documented here, and that are never used in the code. They are gathered in the <a class="el" href="a00142.html">rl::concept</a> namespace. The convention is the following. If you need a rl template whose documentation is like this:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="a00128.html">rl</a> {</div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STUFF, <span class="keyword">typename</span> SA_FOO, <span class="keyword">typename</span> SA_BAR&gt;</div><div class="line">  <span class="keyword">class </span>DummyAlgorithm {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">double</span> computeResult(<span class="keywordtype">void</span>);</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><p>You have to search in the documentation for concepts rl::concept::Stuff, rl::concept::sa::Foo, rl::concept::sa::Bar, as suggests the names of the formal template parameters of DummyAlgorithm. Let us suppose that you find this.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="a00128.html">rl</a> {</div><div class="line">  <span class="keyword">namespace </span>concept {</div><div class="line">  </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ANY&gt;</div><div class="line">    <span class="keyword">class </span>Stuff {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      <span class="keyword">typedef</span> ANY any_type;</div><div class="line">      <span class="keywordtype">void</span> interpret(any_type&amp; a);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">namespace </span>sa {</div><div class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VALUE&gt;</div><div class="line">      <span class="keyword">class </span>FooBase {</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> VALUE value_type;</div><div class="line">        value_type <span class="keyword">get</span>(void);</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VALUE&gt;</div><div class="line">      <span class="keyword">class </span>Foo : <span class="keyword">public</span> FooBase {</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">        <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">const</span> value_type&amp; v);</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">class </span>Bar {</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">         <span class="keyword">static</span> <span class="keywordtype">int</span> size(<span class="keywordtype">void</span>);</div><div class="line">      };</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>It does not mean at all that you have to inherit from the previous classes in order to provide type parameters to the DummyAlgorithm class. Rather, it means that you have to design a class <b>accordingly</b> to the concept classes. Let us make a class that fits all the three rl::concept::Stuff, rl::concept::sa::Foo and rl::concept::sa::Bar concepts. You just have to copy-paste from the concept documentation.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ThreeInOne {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// This fits rl::concept::Stuff&lt;std::string&gt;</span></div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> std::string any_type;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> interpret(any_type&amp; a) { </div><div class="line">    <span class="comment">// your code here </span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// This fits rl::concept::sa::Foo&lt;int&gt;... and </span></div><div class="line">  <span class="comment">// rl::concept::sa::FooBase&lt;int&gt; since Foo inherits </span></div><div class="line">  <span class="comment">// from FooBase</span></div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">int</span> value_type;</div><div class="line"></div><div class="line">  value_type <span class="keyword">get</span>(void) {</div><div class="line">    <span class="comment">// your code here </span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">const</span> value_type&amp; v) {</div><div class="line">    <span class="comment">// your code here </span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// This fits rl::concept::sa::Bar</span></div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> size(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// your code here </span></div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Once this ThreeInOne class is defined, it can be used as a type parameter for the three slots in the DummyAlgorithm template, since it fits the three requirements.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> rl::DummyAlgorithm&lt;ThreeInOne,ThreeInOne,ThreeInOne&gt; MyAlgo;</div><div class="line">...</div><div class="line">MyAlgo algo;</div><div class="line"><span class="keywordtype">double</span> res = algo.computeResult;</div></div><!-- fragment --><p>Fitting to the concepts ensures that your code will compile. It also induce a very strong type checking, that may be annoying at compiling time if you do not perfectly fit the concepts, but that brings a lot of safety at run time.</p>
<h1><a class="anchor" id="functional"></a>
A intensive use of C++-11 function tools</h1>
<p>There are quite a few concepts in the library (since version 3.00.00 !). They are used mainly for the definition of simulators. Fitting a concept often requires to define wrapper classes, in order to make pr-existing code elements compatible with the required concepts. This is why the rl design is rather based on functions, as examples show. Lambda functions and bindings are widely used in the examples, since they provide a powerfull and compact way to wrap things.</p>
<p>This is an example of the use of bindings. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> q_param(<span class="keyword">const</span> Param&amp; theta, S s, A a) {</div><div class="line">  <span class="comment">// compute q_\theta(s,a)</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>std::placeholders; <span class="comment">// defines _1,_2,...</span></div><div class="line"></div><div class="line">Param p;</div><div class="line"></div><div class="line"><span class="comment">// A Q-function takes two arguments, not three. We can get a</span></div><div class="line"><span class="comment">// Q-function by binding the first parameter of q_param to p. </span></div><div class="line"> </div><div class="line"><span class="keyword">auto</span> q1 = std::bind(q_param,p,_1,_2); <span class="comment">// q1(x,y) = q_param(p,x,y).</span></div><div class="line"></div><div class="line"><span class="comment">// The same can be done from a lambda function as well.</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> q2 = [&amp;p](S s, A a) -&gt; <span class="keywordtype">double</span> {<span class="keywordflow">return</span> q_param(p,s,a);};</div><div class="line"></div><div class="line">S s0;</div><div class="line"></div><div class="line"><span class="comment">// If we want to get the best action from s0, we need an action</span></div><div class="line"><span class="comment">// iterator (got from an array here) and a binding.</span></div><div class="line"></div><div class="line">std::array&lt;A,NB_ACTIONS&gt; actions = {{action1,action2,action3,...}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> a_q_pair = <a class="code" href="a00128.html#a7d1e0c77b3b2bf627f01bc743b767487">rl::argmax</a>(std::bind(q1,s0,_1), <span class="comment">// this is f(x) = q1(s0,x).</span></div><div class="line">                           actions.begin(), actions.end());</div><div class="line"><span class="keyword">auto</span> best_a   = a_q_pair.first;</div></div><!-- fragment --><p>Another use of functions is to provide accessors to internal data, or builders, so that algorithm can handle a data without requiring some template fitting. This avoids the above mentionned concept-based wrapping. Let us see an example that gives the taste of the rl library design.</p>
<p>Let us suppose that the library provides an algorithm that sums the real parts of a collection of complex numbers. The sumation algotithm would be written like this.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ITERATOR, <span class="keyword">typename</span> GET_COMPLEX, <span class="keyword">typename</span> GET_REAL&gt;</div><div class="line"><span class="keywordtype">double</span> sum_real_parts(<span class="keyword">const</span> ITERATOR&amp; begin, <span class="keyword">const</span> ITERATOR&amp; end,</div><div class="line">                      <span class="keyword">const</span> GET_COMPLEX&amp; get_complex, </div><div class="line">                      <span class="keyword">const</span> GET_COMPLEX&amp; get_real) {</div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = begin; it != end; ++it) </div><div class="line">    sum += get_real(get_complex(*it));</div><div class="line">  <span class="keywordflow">return</span> sum;</div><div class="line">}</div></div><!-- fragment --><p>The previous code do not expect that the complex are placed within a vector, since general purpose iterators are expected. Moreover, the content of the collection has not to be directly a complex, since get_complex is invoqued to get it. Last, complex are note required to fit some concept telling that c.re has to be a legal expression, since get_real does the job. Let use our algorithm with some data. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> std::pair&lt;double,double&gt; Complex; </div><div class="line"><span class="keyword">struct </span>Data {</div><div class="line">  Complex     value;</div><div class="line">  std::string name;</div><div class="line">  <span class="keywordtype">int</span>         tag;</div><div class="line">};</div><div class="line">std::map&lt;std::string,Data&gt; database = .... ;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> sum = sum_real_parts(database.begin(),database.end(),</div><div class="line">                            [](<span class="keyword">const</span> Data&amp; content) -&gt; Complex {<span class="keywordflow">return</span> content.second.value;}, <span class="comment">// Gets the complex...</span></div><div class="line">                            [](<span class="keyword">const</span> Complex&amp; c)    -&gt; <span class="keywordtype">double</span>  {<span class="keywordflow">return</span> c.first;});             <span class="comment">// ... and from it, its real part.</span></div></div><!-- fragment --><h1><a class="anchor" id="start"></a>
Getting started</h1>
<p>You are now ready to read the examples following the order induced by the file names, and of course you can design you own experiments, inspiring from the code in the examples. In order to compile your code, pkg-config support is available (unix).</p>
<div class="fragment"><div class="line">g++ -o example.bin file.cc `pkg-config --cflags --libs <a class="code" href="a00128.html">rl</a>`</div><div class="line">./example.bin</div></div><!-- fragment --><p> or more generally </p><div class="fragment"><div class="line">g++ -c file1.cc `pkg-config --cflags <a class="code" href="a00128.html">rl</a>`</div><div class="line">g++ -c file2.cc `pkg-config --cflags <a class="code" href="a00128.html">rl</a>`</div><div class="line">...</div><div class="line">g++ -c fileN.cc `pkg-config --cflags <a class="code" href="a00128.html">rl</a>`</div><div class="line"></div><div class="line">g++ -o example.bin *.o `pkg-config --libs <a class="code" href="a00128.html">rl</a>`</div><div class="line">./example.bin</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
